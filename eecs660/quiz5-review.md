# Quiz 5 Review

## Graph Algorithms

If a graph is **dense**, then |E| = O(|V|<sup>2</sup>).

If a graph is **sparse**, then |E| = O(|V|).

A graph can be represented in two ways:

* A **matrix**
  * Pros:
    * The time complexity for determining whether there exists an edge between two given vertices is O(1).
  * Cons:
    * The time complexity for traversing the entire graph is O(|V|<sup>2</sup>).
    * The time complexity to enumerate neighboring vertices is O(|V|).

* An **adjacency list**
  * Pros:
    * The time complexity for traversing the entire graph is O(|V| + |E|).
    * The time complexity to enumerate neighboring vertices is O(1).

  * Cons:
    * The time complexity for determining whether there exists an edge between two given vertices is O(|V|).

## Connectivity s-t Problem

Given two vertices s and t in a graph G = (V, E), determine whether there exists a path between s and t.

### Algorithm

```
BFS(G, s, t):
create empty set S;
create empty queue Q;
Q.enqueue(s);
while Q is not empty:
  current = Q.dequeue();
  if current is the t
    return TRUE;
  endif
  for each node k that is adjacent to the current:
    if k is not in S
      add k to S;
      Q.enqueue(k);
    endif
  endfor
endwhile
return FALSE;
```

```
DFS(G, s, t):
create empty set S;
create empty stack T;
T.push(s);
while S is not empty:
  current = S.pop();
  if current is the t
    return TRUE;
  endif
  for each node k that is adjacent to the current:
    if k is not in S
      add k to S;
      T.push(k);
    endif
  endfor
endwhile
return FALSE;
```

### Proofs

> If t was ever in Q, there exists an s-t path.

Proof by induction:

S will be put in the queue at the beginning since S can reach itself. Thus an s-s path exists.

Assume the statement above is true for the n<sup>th</sup> iteraction of the "while" loop. In other words, given a vertex c where c &ne; s, assume an s-c path exists. All vertices that will be put in Q are adjacent to c and therefore we can construct an s-t by connecting s-c path and c-t path.

> For every two vertices s and t, their connected components are either **identical** or **disjoint**.

If s and t are mutually reachable, then s can also reach all vertices that t can reach by going to t first and then to the target.

Assume if s and t are not connected, there cannot be a vertex v that is shared by the connected components s and t. For that, we can construct an s-t path from s-v and v-t paths, contradicting with the assumption that s and t are not connected.

## Bipartite Graph

For every edge, we must have one end in partition X and the other in partition Y.

### Coloring Strategy

Pick an arbitrary vertex and color it. Color every adjacent vertex with a different color.

We can color the graph G and examine all edges to see if there exists some edge such that both of its ends are assigned with some color. If no such edge exists, then the coloring can be directly translated into the partition. Otherwise, G is *not* a bipartite graph.

### Algorithm

```
BFS(G):
create empty set S;
create empty queue Q;
pick an arbitrary vertex s and color s with red;
Q.enqueue(s);
while Q is not empty
  current = Q.dequeue();
  for each node k that is adjacent to current
    if k is not in S:
      color k with blue;
      add k to S;
      Q.enqueue(k);
    endif
  endfor
endwhile
for e in E
  if e connects two vertices with the same color
    return FALSE;
  endif
endfor
return TRUE;
```

### Time Complexity

Given G(V,E), |V|, and |E|,

1. BFS/DFS with coloring: O(|E| + |V|)
2. Check each edge: O(|E|)

Therefore, O(|E| + |V|) + O(|E|) = O(|E| + |V|)

### Proofs

> If graph G is bipartite, it does not contain an odd cycle.

**BFS**:

Consider the search tree generated by BFS. Let two adjacent vertices having the same color be x and y. Without loss of generality, we can assume x is discovered first.

There are two cases:

1. y is discovered in the same layer of the search tree
2. y is not discovered in the same layer of the search tree

For the second case, the algorithm will discover y immediately after x being discovered because there exists an (x,y) edge. According to the algorithm, if such case happens, x and y must be assigned with different colors which contradicts the condition.

As a result, x and y must be in the same layer of the BFS search tree. In this case, we can construct an odd cycle as follows:

Let s be the source of the BFS, the path u,..,s,..,v, u contains 2l-1 vertices, where l is the layer of x or y. We subtract 1 because otherwise s would be counted twice in the path. Therefore, when the graph coloring algorithm assigns the same color for two adjacent vertices, there exists an odd cycle in the graph G = (V, E).

**DFS**:

Consider the search tree generated by DFS. Let teh two adjacent vertices having the same color be x and y. Denote the lowest common ancestor between u and v in T be lca(x,y).

If lca(x,y) is either x or y, it follows that there exists a well-colors x-y path in T. Since x and y are colored the same, this x-y path must contain an odd number of vertices. Because an edge (x,y) also exists, the path x,...y,x is an odd cycle.

On the other hand, if lca(x,y) is neither x nor y, there exists well-colored lca(x,y)-x and lca(x,y)-y paths. Since x and y are colored the same, the number of vertices in both paths much be both odd or even.

It follows that if we add up the number of vertices in these two paths, the total number of vertices must be even. Since doing this we would add lca(x,y) twice, so subtracting this double-counting we would have the path x-lca(x,y)-y having an odd number of vertices.

Because an edge (x,y) exists, the u,...,lca(u,v),...v, u path is an odd path. Therefore, when the graph coloring algorithm assigns the same color for two adjacent vertices, there exists an odd cycle in the graph G = (V,E).

## Topological Ordering

A **topological ordering** of a directed graph G is an ordering of vertices v<sub>1</sub>, v<sub>2</sub>, ..., v<sub>n</sub> such that for each edge (v<sub>i</sub>, v<sub>j</sub>) &in; E, we have i &lt; j.

### Proofs

> If G is a DAG, then there exists a topological ordering for G.

We need to prove two parts:

> If G is a DAG, there exists a vertex u such that u has no incoming edge.

We can prove this by contradiction. Assume that all vertices in G have at least one incoming edge. Now, we can traverse the graph in the following way. Pick an arbitrary vertex u as the start, follow one of its incoming edge to v. Now we are at v, we can then follow one of the incoming edges of v and go to w. This traversal will never terminate since there exists at least one incoming edge for every vertex. After n+1 steps, we will visit at least one vertex twice. In this case, we have found a cycle in G, contradicting with the fact that G is a DAG.

> If G is a DAG, then G has a topological ordering.

We can prove this by induction. First note that the statement is true for a DAG with size 1 and 2. We assume that the statement is also true for a DAG with size n. Now, in a DAG G with size n+1, by the previous proposition we know that there exists a vertex that has no incoming edge. Temporarily remove this vertext, say u, from the DAG. THe remaining graph is still a DAG since removing vertex u will not introduce a cycle into a graph, leaving DAG G-u.

Based on our assumption, there exists a topological ordering for this size n DAG, so G-u has a topological ordering. We can then put u at the beginning of the topological ordering G-u. Since u has no incoming edge, the concatenation is a valid topological ordering for G. Therefore, by induction, if G is a DAG, then G has a topological ordering.

## Interval Scheduling Problem

### Algorithm

```
Let R be the set of jobs and A be the set of accepted job
Initialze A to be empty
Sort jobs in R based on their finishing time
while R is not empty
  choose the first job i in R
  add i to A
  delete all jobs in R that are conflicting with i
endwhile
return A
```

### Proofs

> All schedules without inversion and idle time will have the same maximum lateness.

For two schedules with no inversions and no idle time, they might only differ from each other in the execution order of tasks with the same deadline. Also, note that all these tasks with the same deadline will be executed consecutively. The maximum lateness of this set of tasks depends only on the finish time of the last task and is independent of the ordering of these tasks. In this case, all ordering of these jobs will result in the same maximized lateness.

> There exists an optimal solution that has no inversion and no idle time.

This is a three part proof:

Assume that O is an optimal schedule and A is the schedule produced by the greedy algorithm.

* If O has an inversion, then there exists a pair of tasks i and j such that j is scheduled immediately after i and has d<sub>i</sub> &gt; d<sub>j</sub>.
  * We assume "shortest" inversion be a and b. By shortest we mean that the difference b-a is minimal among all inversions. If a and b are adjacent, the statement is immediately proved. Otherwise, there exists a schedule of b,x,..,y,a. Since the inversion b, a is minimal, all tasks that are scheduled between b and a, i.e. x,..., y, have their deadlines in order. Hence, we have d<sub>a</sub> &leq; d<sub>x</sub> &leq; . . . &leq; d<sub>y</sub> &lt; d<sub>b</sub> or d<sub>a</sub> &lt; d<sub>x</sub> &leq; . . . &leq; d<sub>y</sub> &leq; d<sub>b</sub>. In the first case, we have two adjacent tasks b and x having that x is immediately scheduled after b and d<sub>b</sub> &gt; d<sub>x</sub>. In the second case, we have two adjacent jobs y and a having that a is immediately scheduled after y and d<sub>y</sub> &gt; d<sub>a</sub>.

* We can then swap the adjacent inversions and make O inversion-free and becomes A.
  * Any jobs that are scheduled before i or j remain being scheduled before them and any jobs that are scheduled after i or j remain being scheduled after them. So, the swapping creates no other inversion but reduce the number of inversions by exactly 1. In the worst case, there only exists (n 2) inversions if we assume every pair of jobs are inversion and it requires a finite number of (n 2) swaps to eliminate all inversions.

* The new swapped schedule has a maximum lateness no larget than that of O.
  * Assume that we swapped an adjacent inversion i,j in O, i.e. we have j being scheduled immediately after i and have d<sub>i</sub> &gt; d<sub>j</sub>. With the swap, we have job j being scheduled earlier and we must not increase the maximum lateness if it is caused by j. The only concern is that job i is postponed and the new schedule will increase its lateness. Let the new lateness of i be l'<sub>i</sub> and the new finishing time of i be f'<sub>i</sub>. Note that in the new schedule, job i will be finished the same time as j in the old schedule and therefore f'<sub>i</sub> = f<sub>j</sub>. Now, we have l'<sub>i</sub> = f'<sub>i</sub> - d<sub>i</sub> = f<sub>j</sub> - d<sub>i</sub> &lt; f<sub>j</sub> - d<sub>j</sub> = l<sub>j</sub>. It follows that the lateness of job i in the new schedule remains smaller than the lateness of job j in the old schedule. In this case, after swapping, neither the lateness of jobs i nor j will surpass the lateness of job j prior to swapping.

Taken together, there is a way to convert O into a schedule without inversion through swapping. Since the greedy algorithm can produce a schedule without inversion and all schedules without inversions have the same maximum lateness, the schedule produced by the greedy algorithm is optimal.

