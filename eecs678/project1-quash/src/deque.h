/**
 * @file deque.h
 *
 * @brief Double ended queue generators specialized to any given type.
 */

#ifndef SRC_DEQUE_H
#define SRC_DEQUE_H

#include <assert.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>

/**
 * @def IMPLEMENT_DEQUE_STRUCT(struct_name, type)
 *
 * @brief Generates a structure for use with Double Ended Queues.
 *
 * Follow this call with either @a PROTOTYPE_DEQUE() (if in a header file) or @a
 * IMPLEMENT_DEQUE() to generate the functions
 * that correspond to this structure. The structure fields should not be
 * manually changed at any time. Instead use one of the generated functions from
 * the aforementioned macros.
 *
 * @param struct_name The name of the structure
 *
 * @param type The name of the type of elements stored in the @a struct_name
 * structure
 *
 * @sa PROTOTYPE_DEQUE, IMPLEMENT_DEQUE
*/
#define IMPLEMENT_DEQUE_STRUCT(struct_name, type)                       \
  typedef struct struct_name {                                          \
    type* data;                                                         \
    size_t cap;                                                         \
    size_t front;                                                       \
    size_t back;                                                        \
                                                                        \
    void (*destructor)(type);                                           \
  } struct_name;

/**
 * @def PROTOTYPE_DEQUE(struct_name, type)
 *
 * @brief Generates prototypes for functions that manipulate Double Ended Queue
 * structures.
 *
 * This is intended for use in a header file or anywhere you need a forward
 * declaration of these functions. This does not actually implement these
 * functions.
 *
 * @param struct_name The name of the structure
 *
 * @param type The name of the type of elements stored in the @a struct_name
 * structure
 *
 * @sa IMPLEMENT_DEQUE_STRUCT(), IMPLEMENT_DEQUE()
 */
#define PROTOTYPE_DEQUE(struct_name, type)                              \
  struct_name new_##struct_name(size_t);                                \
  struct_name new_destructable_##struct_name(size_t, void (*)(type));   \
  void destroy_##struct_name(struct_name*);                             \
  void empty_##struct_name(struct_name*);                               \
  bool is_empty_##struct_name(struct_name*);                            \
  size_t length_##struct_name(struct_name*);                            \
  type* as_array_##struct_name(struct_name*, size_t*);                  \
  void apply_##struct_name(struct_name*, void (*)(type));               \
  void push_front_##struct_name(struct_name*, type);                    \
  void push_back_##struct_name(struct_name*, type);                     \
  type pop_front_##struct_name(struct_name*);                           \
  type pop_back_##struct_name(struct_name*);                            \
  type peek_front_##struct_name(struct_name*);                          \
  type peek_back_##struct_name(struct_name*);                           \
  void update_front_##struct_name(struct_name*, type);                  \
  void update_back_##struct_name(struct_name*, type);                   \
  void update_and_destroy_front_##struct_name(struct_name*, type);      \
  void update_and_destroy_back_##struct_name(struct_name*, type);

/**
 * @def IMPLEMENT_DEQUE(struct_name, type)
 *
 * @brief Generates a @a malloc based set of functions for use with a structure
 * generated by @a IMPLEMENT_DEQUE_STRUCT()
 *
 * @param struct_name The name of the structure
 *
 * @param type The name of the type of elements stored in the @a struct_name
 * structure
 *
 * @sa IMPLEMENT_DEQUE_STRUCT(), PROTOTYPE_DEQUE()
 */
#define IMPLEMENT_DEQUE(struct_name, type)                              \
                                                                        \
  void apply_##struct_name(struct_name*, void (*)(type));               \
                                                                        \
  struct_name new_##struct_name(size_t init_cap) {                      \
    struct_name ret;                                                    \
                                                                        \
    if (init_cap > 0)                                                   \
      ret.cap = init_cap;                                               \
    else                                                                \
      ret.cap = 1;                                                      \
                                                                        \
    ret.data = (type*) malloc(ret.cap * sizeof(type));                  \
                                                                        \
    if (ret.data == NULL) {                                             \
      fprintf(stderr, "ERROR: Failed to allocate struct_name"           \
              " contents");                                             \
      exit(-1);                                                         \
    }                                                                   \
                                                                        \
    ret.front = ret.back = 0;                                           \
    ret.destructor = NULL;                                              \
                                                                        \
    return ret;                                                         \
  }                                                                     \
                                                                        \
  struct_name new_destructable_##struct_name(size_t init_cap,           \
                                             void (*destructor)(type)){ \
    struct_name ret = new_##struct_name(init_cap);                      \
    ret.destructor = destructor;                                        \
    return ret;                                                         \
  }                                                                     \
                                                                        \
  void destroy_##struct_name(struct_name* deq) {                        \
    assert(deq != NULL);                                                \
                                                                        \
    if (deq->data == NULL)                                              \
      return;                                                           \
                                                                        \
    if (deq->destructor != NULL)                                        \
      apply_##struct_name(deq, deq->destructor);                        \
                                                                        \
    if (deq->data != NULL)                                              \
      free(deq->data);                                                  \
                                                                        \
    deq->data = NULL;                                                   \
    deq->cap = deq->front = deq->back = 0;                              \
  }                                                                     \
                                                                        \
  void empty_##struct_name(struct_name* deq) {                          \
    assert(deq != NULL);                                                \
    assert(deq->data != NULL); /* Make sure the structure is valid */   \
                                                                        \
    if (deq->destructor != NULL)                                        \
      apply_##struct_name(deq, deq->destructor);                        \
                                                                        \
    deq->front = deq->back = 0;                                         \
  }                                                                     \
                                                                        \
  bool is_empty_##struct_name(struct_name* deq) {                       \
    assert(deq != NULL);                                                \
    assert(deq->data != NULL); /* Make sure the structure is valid */   \
    return deq->front == deq->back;                                     \
  }                                                                     \
                                                                        \
  size_t length_##struct_name(struct_name* deq) {                       \
    assert(deq != NULL);                                                \
    assert(deq->data != NULL); /* Make sure the structure is valid */   \
    return (deq->back - deq->front + deq->cap) % deq->cap;              \
  }                                                                     \
                                                                        \
  static void __reallign_##struct_name(struct_name* deq) {              \
    assert(deq != NULL);                                                \
    assert(deq->data != NULL); /* Make sure the structure is valid */   \
                                                                        \
    if (deq->front != 0) {                                              \
      type* old_data = deq->data;                                       \
      size_t len = length_##struct_name(deq);                           \
                                                                        \
      deq->data = (type*) malloc(deq->cap * sizeof(type));              \
                                                                        \
      if (deq->data == NULL) {                                          \
        fprintf(stderr, "ERROR: Failed to reallocate struct_name"       \
                " contents");                                           \
        abort();                                                        \
      }                                                                 \
                                                                        \
      size_t i;                                                         \
                                                                        \
      for (i = 0; i < len; ++i)                                         \
        deq->data[i] = old_data[(deq->front + i) % deq->cap];           \
                                                                        \
      free(old_data);                                                   \
                                                                        \
      deq->front = 0;                                                   \
      deq->back = i;                                                    \
    }                                                                   \
  }                                                                     \
                                                                        \
  type* as_array_##struct_name(struct_name* deq, size_t* len) {         \
    assert(deq != NULL);                                                \
    assert(deq->data != NULL); /* Make sure the structure is valid */   \
                                                                        \
    __reallign_##struct_name(deq);                                      \
                                                                        \
    type* ret = deq->data;                                              \
                                                                        \
    if (len != NULL)                                                    \
      *len = length_##struct_name(deq);                                 \
                                                                        \
    deq->data = NULL;                                                   \
    deq->cap = deq->front = deq->back = 0;                              \
                                                                        \
    return ret;                                                         \
  }                                                                     \
                                                                        \
  void apply_##struct_name(struct_name* deq, void (*func)(type)) {      \
    assert(deq != NULL);                                                \
    assert(deq->data != NULL); /* Make sure the structure is valid */   \
                                                                        \
    size_t len = length_##struct_name(deq);                             \
                                                                        \
    for (size_t i = 0; i < len; ++i) {                                  \
      func(deq->data[(deq->front + i) % deq->cap]);                     \
    }                                                                   \
  }                                                                     \
                                                                        \
  static void __on_push_##struct_name(struct_name* deq) {               \
    if (deq->front == (deq->back + 1) % deq->cap) {                     \
      type* old_data = deq->data;                                       \
      size_t old_cap = deq->cap;                                        \
                                                                        \
      deq->cap = 2 * deq->cap;                                          \
      deq->data = (type*) malloc(deq->cap * sizeof(type));              \
                                                                        \
      if (deq->data == NULL) {                                          \
        fprintf(stderr, "ERROR: Failed to reallocate struct_name"       \
                " contents\n");                                         \
        abort();                                                        \
      }                                                                 \
                                                                        \
      size_t i;                                                         \
                                                                        \
      for (i = 0; i < old_cap - 1; ++i)                                 \
        deq->data[i] = old_data[(deq->front + i) % old_cap];            \
                                                                        \
      free(old_data);                                                   \
                                                                        \
      deq->front = 0;                                                   \
      deq->back = i;                                                    \
    }                                                                   \
  }                                                                     \
                                                                        \
  static void __on_pop_##struct_name(struct_name* deq) {                \
    if (is_empty_##struct_name(deq)) {                                  \
      fprintf(stderr, "ERROR: Cannot pop from of struct_name while it " \
              "is empty\n");                                            \
      abort();                                                          \
    }                                                                   \
  }                                                                     \
                                                                        \
  void push_front_##struct_name(struct_name* deq, type element) {       \
    assert(deq != NULL);                                                \
    assert(deq->data != NULL); /* Make sure the structure is valid */   \
    __on_push_##struct_name(deq);                                       \
    deq->front = (deq->front + deq->cap - 1) % deq->cap;                \
    deq->data[deq->front] = element;                                    \
  }                                                                     \
                                                                        \
  void push_back_##struct_name(struct_name* deq, type element) {        \
    assert(deq != NULL);                                                \
    assert(deq->data != NULL); /* Make sure the structure is valid */   \
    __on_push_##struct_name(deq);                                       \
    deq->data[deq->back] = element;                                     \
    deq->back = (deq->back + 1) % deq->cap;                             \
  }                                                                     \
                                                                        \
  type pop_front_##struct_name(struct_name* deq) {                      \
    assert(deq != NULL);                                                \
    assert(deq->data != NULL); /* Make sure the structure is valid */   \
    __on_pop_##struct_name(deq);                                        \
    size_t old_front = deq->front;                                      \
    deq->front = (deq->front + 1) % deq->cap;                           \
    return deq->data[old_front];                                        \
  }                                                                     \
                                                                        \
  type pop_back_##struct_name(struct_name* deq) {                       \
    assert(deq != NULL);                                                \
    assert(deq->data != NULL); /* Make sure the structure is valid */   \
    __on_pop_##struct_name(deq);                                        \
    deq->back = (deq->back + deq->cap - 1) % deq->cap;                  \
    return deq->data[deq->back];                                        \
  }                                                                     \
                                                                        \
  type peek_front_##struct_name(struct_name* deq) {                     \
    assert(deq != NULL);                                                \
    assert(deq->data != NULL); /* Make sure the structure is valid */   \
    assert(!is_empty_##struct_name(deq));                               \
    return deq->data[deq->front];                                       \
  }                                                                     \
                                                                        \
  type peek_back_##struct_name(struct_name* deq) {                      \
    assert(deq != NULL);                                                \
    assert(deq->data != NULL); /* Make sure the structure is valid */   \
    assert(!is_empty_##struct_name(deq));                               \
    return deq->data[(deq->back + deq->cap - 1) % deq->cap];            \
  }                                                                     \
                                                                        \
  void update_front_##struct_name(struct_name* deq, type element) {     \
    assert(deq != NULL);                                                \
    assert(deq->data != NULL); /* Make sure the structure is valid */   \
    assert(!is_empty_##struct_name(deq));                               \
    deq->data[deq->front] = element;                                    \
  }                                                                     \
                                                                        \
  void update_back_##struct_name(struct_name* deq, type element) {      \
    assert(deq != NULL);                                                \
    assert(deq->data != NULL); /* Make sure the structure is valid */   \
    assert(!is_empty_##struct_name(deq));                               \
    deq->data[(deq->back + deq->cap - 1) % deq->cap] = element;         \
  }                                                                     \
                                                                        \
  void update_and_destroy_front_##struct_name(struct_name* deq,         \
                                              type element) {           \
    assert(deq != NULL);                                                \
    assert(deq->data != NULL); /* Make sure the structure is valid */   \
    assert(!is_empty_##struct_name(deq));                               \
                                                                        \
    size_t idx = deq->front;                                            \
                                                                        \
    if (deq->destructor != NULL)                                        \
      deq->destructor(deq->data[idx]);                                  \
                                                                        \
    deq->data[idx] = element;                                           \
  }                                                                     \
                                                                        \
  void update_and_destroy_back_##struct_name(struct_name* deq,          \
                                             type element) {            \
    assert(deq != NULL);                                                \
    assert(deq->data != NULL); /* Make sure the structure is valid */   \
    assert(!is_empty_##struct_name(deq));                               \
                                                                        \
    size_t idx = (deq->back + deq->cap - 1) % deq->cap;                 \
                                                                        \
    if (deq->destructor != NULL)                                        \
      deq->destructor(deq->data[idx]);                                  \
                                                                        \
    deq->data[idx] = element;                                           \
  }

// The following deque is for example and documentation purposes only

/** @brief An example type used for example purposes only */
typedef char Type;

/**
 * @struct Example
 *
 * @brief A data structure generated by IMPLEMENT_DEQUE_STRUCT() to store the
 * state of a deque.
 *
 * @note The members of this struct should not be accessed or modified directly.
 * For modification please use the functions generated by the IMPLEMENT_DEQUE()
 * macro.
 *
 * @sa IMPLEMENT_DEQUE()
 */
// The following is the struct created by the expansion of
// IMPLEMENT_DEQUE_STRUCT(Example, Type);
typedef struct Example {
  Type* data;   /**< The array holding the deque */
  size_t cap;   /**< The current capacity of the deque */
  size_t front; /**< The index of the element at the front of the deque */
  size_t back;  /**< The index one greater than the last element of the queue */

  void (*destructor)(Type); /**< Optional destructor function pointer for the
                             *  data type. This is called on every element in
                             *  the queue when @a destroy_Example() is called.
                             *
                             *  @note We will have a lab over function pointers
                             *  later in the semester. If this doesn't make sense
                             *  now then skip it or come to your TA for
                             *  assistance if you really want to use it.*/
} Example; /**< @brief This way you do not have to type "struct Example" each
            *  time you wish to refer to an Example structure */

/**
 * @fn Example new_Example(size_t init_cap)
 *
 * @brief Create a new, fully initialized deque structure
 *
 * @param init_cap Initial capacity of the deque
 *
 * @return A copy of the fully initialized struct
 *
 * @sa Example
 */
/**
 * @fn Example new_destructable_Example(size_t init_cap, void
 * (*destructor)(Type))
 *
 * @brief Create a new, fully initialized deque structure with a destructor that
 * is applied to every element when the @a destroy_Example() function is called
 *
 * Specifying the destructor is useful to not have to manually iterate over the
 * deque destroying any malloc'd memory in each element.
 *
 * @param init_cap Initial capacity of the deque
 *
 * @param destructor A function that is run on each element in the deque when @a
 * destroy_Example() is called
 *
 * @return A copy of the fully initialized struct
 *
 * @sa Example
 */
/**
 * @fn void destroy_Example(Example* deq)
 *
 * @brief Destroy the deque structure freeing memory if necessary
 *
 * @param deq A pointer to the deque to destory
 *
 * @sa Example
 */
/**
 * @fn void empty_Example(Example* deq)
 *
 * @brief Quickly empties the deque structure calling a destructor on each
 * element in the deque if a destructor was specified.
 *
 * @param deq A pointer to the deque to empty
 *
 * @sa Example
 */
/**
 * @fn bool is_empty_Example(Example* deq)
 *
 * @brief Checks if the deque is empty
 *
 * @param deq A pointer to the deque to check if empty
 *
 * @return Returns true if empty and false if not empty
 *
 * @sa Example
 */
/**
 * @fn size_t length_Example(Example* deq)
 *
 * @brief Query the number of elements in the deque
 *
 * @param deq A pointer to the deque to calculate the length of
 *
 * @return The number of elements in the deque
 *
 * @sa Example
 */
/**
 * @fn Type* as_array_Example(Example* deq, size_t* len)
 *
 * @brief Extract an array based off the deque
 *
 * @note Calling this function on a deque will invalidate the deque. This means
 * no further deque functions can be called on the deq until it is reinitialized
 * with @a new_Example(). If this function was created with the @a
 * IMPLEMENT_DEQUE() macro, then the destructor is never called and you will be
 * responsible for freeing the memory of the array.
 *
 * @param deq in A pointer to the deque to extract an array from
 *
 * @param[out] len A pointer to an size_t value. This value will be set to the
 * current length of the deque returned from the length_Example() function. If
 * knowing the length of the array is unnecessary then NULL may be passed as
 * this parameter.
 *
 * @return An array containing the data from the deque
 *
 * @sa Example, Type
 */
/**
 * @fn void apply_Example(Example* deq, void (*func)(Type))
 *
 * @brief Calls the function func on every element in the deque
 *
 * @note We will have a lab over function pointers later in the semester. If
 * this doesn't make sense now then skip it or come to your TA for assistance if
 * you really want to use it.
 *
 * @param deq A pointer to the deque to apply the function func to
 *
 * @param func A pointer to a function that takes an element of type
 *
 * @sa Example, Type
 */
/**
 * @fn void push_front_Example(Example* deq, Type element)
 *
 * @brief Insert an element to the front of the deque
 *
 * @param deq A pointer to the deque to insert the element
 *
 * @param element The element to copy into the deque
 *
 * @sa Example, Type
 */
/**
 * @fn void push_back_Example(Example* deq, Type element)
 *
 * @brief Insert an element to the back of the deque
 *
 * @param deq A pointer to the deque to insert the element
 *
 * @param element The element to copy into the deque
 *
 * @sa Example, Type
 */
/**
 * @fn Type pop_front_Example(Example* deq)
 *
 * @brief Remove an element from the front of the deque
 *
 * @param deq A pointer to the deque to remove an element from
 *
 * @return A copy of the element removed from the front of the deque
 *
 * @sa Example, Type
 */
/**
 * @fn Type pop_back_Example(Example* deq)
 *
 * @brief Remove an element from the back of the deque
 *
 * @param deq A pointer to the deque to remove an element from
 *
 * @return A copy of the element removed from the back of the deque
 *
 * @sa Example, Type
 */
/**
 * @fn Type peek_front_Example(Example* deq)
 *
 * @brief Get a copy of the element at the front of the deque
 *
 * @param deq A pointer to the deque to view the first element from
 *
 * @return A copy of the element at the front of the deque
 *
 * @sa Example, Type
 */
/**
 * @fn Type peek_back_Example(Example* deq)
 *
 * @brief Remove an element from the back of the deque
 *
 * @param deq A pointer to the deque to view the last element from
 *
 * @return A copy of the element removed from the back of the queue
 *
 * @sa Example, Type
 */
/**
 * @fn void update_front_Example(Example* deq, Type element)
 *
 * @brief Change the element at the front of the deque to be a copy of element
 * If a destructor is presesnt, then call the destructor on the value of the
 * element that is being replaced.
 *
 * @param deq A pointer to the deque to update
 *
 * @param element The element to update the first element to
 *
 * @sa Example, Type
 */
/**
 * @fn void update_back_Example(Example* deq, Type element)
 *
 * @brief Change the element at the back of the deque to be a copy of element.
 * If a destructor is presesnt, then call the destructor on the value of the
 * element that is being replaced.
 *
 * @param deq A pointer to the deque to update
 *
 * @param element The element to copy into the current last element in the deque
 *
 * @sa Example, Type
 */
/**
 * @fn void update_front_Example(Example* deq, Type element)
 *
 * @brief Change the element at the front of the deque to be a copy of element.
 * This will NOT call the destructor on the old element. This is useful for
 * simply replacing a few fields.
 *
 * @param deq A pointer to the deque to update
 *
 * @param element The element to update the first element to
 *
 * @sa Example, Type
 */
/**
 * @fn void update_back_Example(Example* deq, Type element)
 *
 * @brief Change the element at the back of the deque to be a copy of element.
 * This will NOT call the destructor on the old element. This is useful for
 * simply replacing a few fields.
 *
 * @param deq A pointer to the deque to update
 *
 * @param element The element to copy into the current last element in the deque
 *
 * @sa Example, Type
 */
/**
 * @fn void update_and_destroy_front_Example(Example* deq, Type element)
 *
 * @brief Change the element at the front of the deque to be a copy of element.
 * If a destructor is presesnt, then call the destructor on the element that is
 * being replaced.
 *
 * @param deq A pointer to the deque to update
 *
 * @param element The element to update the first element to
 *
 * @sa Example, Type
 */
/**
 * @fn void update_and_destroy_back_Example(Example* deq, Type element)
 *
 * @brief Change the element at the back of the deque to be a copy of element.
 * If a destructor is presesnt, then call the destructor on the element that is
 * being replaced.
 *
 * @param deq A pointer to the deque to update
 *
 * @param element The element to copy into the current last element in the deque
 *
 * @sa Example, Type
 */
PROTOTYPE_DEQUE(Example, Type);

#endif //SRC_DEQUE_H
